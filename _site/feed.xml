<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-06-05T16:03:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hong Seok Pyo</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</subtitle><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><entry><title type="html">프로그래머스 연습문제 - 겹치는 선분의 길이</title><link href="http://localhost:4000/jekyll/update/2023/05/27/pratice-2.html" rel="alternate" type="text/html" title="프로그래머스 연습문제 - 겹치는 선분의 길이" /><published>2023-05-27T20:29:14+09:00</published><updated>2023-05-27T20:29:14+09:00</updated><id>http://localhost:4000/jekyll/update/2023/05/27/pratice-2</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/05/27/pratice-2.html"><![CDATA[<p>프로그래머스 - 코딩테스트 연습 - 겹치는 선분의 길이
<br /></p>

<p><strong>문제</strong><br />
선분 3개가 평행하게 놓여 있습니다. 세 선분의 시작과 끝 좌표가 [[start, end], [start, end], [start, end]] 형태로 들어있는 2차원 배열 lines가 매개변수로 주어질 때, 두 개 이상의 선분이 겹치는 부분의 길이를 return 하도록 solution 함수를 완성해보세요.</p>

<p>lines가 [[0, 2], [-3, -1], [-2, 1]]일 때 그림으로 나타내면 다음과 같습니다.</p>

<p><br /></p>

<p><img src="https://github.com/Son-Bin-O/son-bin-o.github.io/blob/main/images/line.png?raw=true" alt="img" />
<!-- <img src="/images/line.png"> --></p>

<p><br />
<strong>제한사항</strong></p>
<ul>
  <li>lines의 길이 = 3</li>
  <li>lines의 원소의 길이 = 2</li>
  <li>모든 선분은 길이가 1 이상입니다.</li>
  <li>lines의 원소는 [a, b] 형태이며, a, b는 각각 선분의 양 끝점 입니다.
-100 ≤ a &lt; b ≤ 100
<br /><br /></li>
</ul>

<p><strong>입출력 예</strong></p>

<table>
  <thead>
    <tr>
      <th>lines</th>
      <th>results</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[[0, 1], [2, 5], [3, 9]]</td>
      <td>2</td>
    </tr>
    <tr>
      <td>[[-1, 1], [1, 3], [3, 9]]</td>
      <td>0</td>
    </tr>
    <tr>
      <td>[[0, 5], [3, 9], [1, 10]]</td>
      <td>8</td>
    </tr>
  </tbody>
</table>

<p><br />
<strong>풀이</strong>
<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def solution(lines):
    answer = 0
    start1, end1 = lines[0][0], lines[0][1]
    start2, end2 = lines[1][0], lines[1][1]
    start3, end3 = lines[2][0], lines[2][1]
    m_sta = min(start1, start2, start3)
    m_end = max(end1, end2, end3)
    over_1 = []
    over_2 = []
    over_3 = []
    result = []
    
    for i in range(m_sta, m_end+1):
        if start1 &lt;= i &lt;= end1 and start2 &lt;= i &lt;= end2:
            over_1.append(i)
    
        if start2 &lt;= i &lt;= end2 and start3 &lt;= i &lt;= end3:
            over_2.append(i)
            
        if start1 &lt;= i &lt;= end1 and start3 &lt;= i &lt;= end3:
            over_3.append(i)
    
    merged = over_1 + over_2 + over_3
    result2 = list(set(merged))
    result2.sort()
            
    if len(over_1) + len(over_2) + len(over_3) == len(result2):
        if over_1 != []:
            answer += over_1[-1] - over_1[0]
        if over_2 != []:
            answer += over_2[-1] - over_2[0]
        if over_3 != [] :
            answer += over_3[-1] - over_3[0]
    else:
        answer = result2[-1] - result2[0]

    return answer
</code></pre></div></div>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[프로그래머스 - 코딩테스트 연습 - 겹치는 선분의 길이]]></summary></entry><entry><title type="html">프로그래머스 연습문제 - 평행</title><link href="http://localhost:4000/jekyll/update/2023/05/27/practice.html" rel="alternate" type="text/html" title="프로그래머스 연습문제 - 평행" /><published>2023-05-27T20:22:31+09:00</published><updated>2023-05-27T20:22:31+09:00</updated><id>http://localhost:4000/jekyll/update/2023/05/27/practice</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/05/27/practice.html"><![CDATA[<p>프로그래머스 - 코딩테스트 연습 - 평행
<br /></p>

<p><strong>문제</strong><br />
점 네 개의 좌표를 담은 이차원 배열  dots가 다음과 같이 매개변수로 주어집니다.
[[x1, y1], [x2, y2], [x3, y3], [x4, y4]]
주어진 네 개의 점을 두 개씩 이었을 때, 두 직선이 평행이 되는 경우가 있으면 1을 없으면 0을 return 하도록 solution 함수를 완성해보세요.</p>

<p><br />
<strong>제한사항</strong></p>
<ul>
  <li>dots의 길이 = 4</li>
  <li>dots의 원소는 [x, y] 형태이며 x, y는 정수입니다.</li>
  <li>0 ≤ x, y ≤ 100</li>
  <li>서로 다른 두개 이상의 점이 겹치는 경우는 없습니다.</li>
  <li>두 직선이 겹치는 경우(일치하는 경우)에도 1을 return 해주세요.</li>
  <li>임의의 두 점을 이은 직선이 x축 또는 y축과 평행한 경우는 주어지지 않습니다.
<br /><br /></li>
</ul>

<p><strong>입출력 예</strong></p>

<table>
  <thead>
    <tr>
      <th>dots</th>
      <th>results</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[[1, 4], [9, 2], [3, 8], [11, 6]]</td>
      <td>1</td>
    </tr>
    <tr>
      <td>[[3, 5], [4, 1], [2, 4], [5, 10]]</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p><br />
<strong>풀이</strong>
<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def solution(dots):
    answer = 0
    my_list = []
    
    for i in range(len(dots)):
        for j in range(i+1,len(dots)):
            x_diff = dots[j][0] - dots[i][0]
            y_diff = dots[j][1] - dots[i][1]
            my_list.append(y_diff/x_diff)
    lens = len(my_list)
    list_a = [[my_list[i] , my_list[lens-1-i]] for i in range(lens//2)]
    
    for i in range(len(list_a)):
        if list_a[i][0] == list_a[i][1]:
            answer = 1    

    return answer
</code></pre></div></div>

<ul>
  <li>반복문 사용</li>
  <li>평행하는 선분 == 기울기 같은 선분</li>
</ul>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[프로그래머스 - 코딩테스트 연습 - 평행]]></summary></entry><entry><title type="html">프로그래머스 연습문제 - 옹알이(1)</title><link href="http://localhost:4000/jekyll/update/2023/05/26/practice.html" rel="alternate" type="text/html" title="프로그래머스 연습문제 - 옹알이(1)" /><published>2023-05-26T20:02:02+09:00</published><updated>2023-05-26T20:02:02+09:00</updated><id>http://localhost:4000/jekyll/update/2023/05/26/practice</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/05/26/practice.html"><![CDATA[<p>프로그래머스 - 코딩테스트 연습 - 옹알이(1)
<br /></p>

<p><strong>문제</strong><br />
머쓱이는 태어난 지 6개월 된 조카를 돌보고 있습니다. 조카는 아직 “aya”, “ye”, “woo”, “ma” 네 가지 발음을 최대 한 번씩 사용해 조합한(이어 붙인) 발음밖에 하지 못합니다. 문자열 배열 babbling이 매개변수로 주어질 때, 머쓱이의 조카가 발음할 수 있는 단어의 개수를 return하도록 solution 함수를 완성해주세요.</p>

<p><br />
<strong>제한사항</strong></p>
<ul>
  <li>1 ≤ babbling의 길이 ≤ 100</li>
  <li>1 ≤ babbling[i]의 길이 ≤ 15</li>
  <li>babbling의 각 문자열에서 “aya”, “ye”, “woo”, “ma”는 각각 최대 한 번씩만 등장합니다.</li>
  <li>즉, 각 문자열의 가능한 모든 부분 문자열 중에서 “aya”, “ye”, “woo”, “ma”가 한 번씩만 등장합니다.
문자열은 알파벳 소문자로만 이루어져 있습니다.
<br /><br /></li>
</ul>

<p><strong>입출력 예</strong></p>

<table>
  <thead>
    <tr>
      <th>babbling</th>
      <th>results</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[“aya”, “yee”, “u”, “maa”, “wyeoo”]</td>
      <td>1</td>
    </tr>
    <tr>
      <td>[“ayaye”, “uuuma”, “ye”, “yemawoo”, “ayaa”]</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p><br />
<strong>풀이</strong>
<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def solution(babbling):
    answer = 0
    words = ["aya", "ye", "woo", "ma"]
    my_list = []
    
    for i in babbling:
        for j in words:
            i = i.replace(j, 'x')   
        my_list.append(i)

    answer = [word for word in my_list if all(cha == 'x' for cha in word)] 
    
    return len(answer)
</code></pre></div></div>

<ul>
  <li>replace의 사용</li>
  <li>리스트 컴프리헨션, all 메서드</li>
</ul>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[프로그래머스 - 코딩테스트 연습 - 옹알이(1)]]></summary></entry><entry><title type="html">프로그래머스 문제 &amp;amp; 파이썬 메모</title><link href="http://localhost:4000/jekyll/update/2023/05/19/programmers.html" rel="alternate" type="text/html" title="프로그래머스 문제 &amp;amp; 파이썬 메모" /><published>2023-05-19T16:52:42+09:00</published><updated>2023-05-19T16:52:42+09:00</updated><id>http://localhost:4000/jekyll/update/2023/05/19/programmers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/05/19/programmers.html"><![CDATA[<p>반복적으로 나오는 기본 메서드들은 확실히 기억해 놓자. (자료형으로 나눠서 메서드들을 기억하는 게 좋을 것 같다)</p>

<p><strong>문자형</strong>은 immutable 자료형 &gt; 슬라이싱으로 처리, 내용을 변경할 수 없다.<br />
<strong>리스트</strong>, <strong>딕셔너리</strong>, <strong>집합형</strong>은 mutable 자료형<br />
<strong>문자형</strong>, <strong>리스트</strong>, <strong>딕셔너리</strong>는 시퀀스 자료형<br />
<br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>문자열.split(sep=구분자, maxsplit=분할횟수) &gt; 리스트로 반환
리스트.append()
리스트.insert
리스트.sort(opt(reverse=True)) &gt; 원본값 변경
sorted(리스트) &gt; 새로운 리스트 반환
' '.join(리스트) 
문자열.replace('A', 'B') / 연결해서 사용 가능
strip() &gt; 공백 제거, 문자 제거
del 리스트
리스트.remove()
리스트.pop()
문자열.find()
문자열.rfind()
리스트 나누기 &gt; 리스트[start:end:split]
arr = [[0] * n for _ in range(n)]
range(start, stop, step)
.count()
round(num, digit)
</code></pre></div></div>
<p><br />
한번 더 풀어볼 것.</p>

<ul>
  <li>배열의 원소만큼 추가하기</li>
  <li>문자열 바꿔서 찾기</li>
  <li>꼬리 문자열</li>
  <li>0 떼기 (break)</li>
  <li>l로 만들기<br />
replace는 새로운 문자열 반환, 슬라이싱으로 처리하자</li>
  <li>할 일 목록<br />
zip() 함수는 이터레이터를 반환, 인덱스 사용이 불필요. 언패킹 활용 가능</li>
  <li>주사위 게임2</li>
  <li>배열의 원소 삭제하기</li>
  <li>가까운 1 찾기</li>
  <li>특별한 이차원 배열1,2</li>
  <li>9로 나눈 나머지</li>
  <li>그림확대</li>
  <li>배열만들기 2</li>
  <li>배열만들기 4</li>
  <li>배열만들기 6</li>
  <li>수열과 구간 쿼리</li>
  <li>주사위 게임 3 (딕셔너리 자료형 활용)
<br /></li>
</ul>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[반복적으로 나오는 기본 메서드들은 확실히 기억해 놓자. (자료형으로 나눠서 메서드들을 기억하는 게 좋을 것 같다)]]></summary></entry><entry><title type="html">Python &amp;amp; javascript-01 (w/Chatgpt)</title><link href="http://localhost:4000/jekyll/update/2023/05/18/python-javascriptw.html" rel="alternate" type="text/html" title="Python &amp;amp; javascript-01 (w/Chatgpt)" /><published>2023-05-18T19:46:17+09:00</published><updated>2023-05-18T19:46:17+09:00</updated><id>http://localhost:4000/jekyll/update/2023/05/18/python-javascriptw</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/05/18/python-javascriptw.html"><![CDATA[<p><strong>문제1.</strong>      <br />
길이가 같은 문자열 배열 my_strings와 이차원 정수 배열 parts가 매개변수로 주어집니다. parts[i]는 [s, e] 형태로, my_string[i]의 인덱스 s부터 인덱스 e까지의 부분 문자열을 의미합니다. 각 my_strings의 원소의 parts에 해당하는 부분 문자열을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.</p>

<p><strong>제한사항</strong></p>
<ul>
  <li>1 ≤ my_strings의 길이 = parts의 길이 ≤ 100</li>
  <li>1 ≤ my_strings의 원소의 길이 ≤ 100</li>
  <li>parts[i]를 [s, e]라 할 때, 다음을 만족합니다.</li>
  <li>0 ≤ s ≤ e &lt; my_strings[i]의 길이</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>** javascript
function solution(my_strings, parts) {
let answer = '';
for (let i = 0; i &lt; my_strings.length; i++) {
	answer += my_strings[i].substring(parts[i][0], parts[i][1] + 1);
}
return answer;
}

** python
def solution(my_strings, parts):
	answer = ''
	for i in range(len(my_strings)):
			answer += my_strings[i][parts[i][0]:parts[i][1]+1]
	return answer**
</code></pre></div></div>
<p><br /><br /></p>

<p><strong>문제2.</strong>    <br />
길이가 같은 두 문자열 str1과 str2가 주어집니다.
두 문자열의 각 문자가 앞에서부터 서로 번갈아가면서 한 번씩 등장하는 문자열을 만들어 return 하는 solution 함수를 완성해 주세요.</p>

<p><strong>제한사항</strong></p>
<ul>
  <li>1 ≤ str1의 길이 = str2의 길이 ≤ 10</li>
  <li>str1과 str2는 알파벳 소문자로 이루어진 문자열입니다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>** python
def solution(str1, str2):
	answer = ''
	for i in range(len(str1)):
			answer += str1[i]+str2[i]
	return answer

** javascript
function solution(str1, str2) {
let answer = '';
for (let i = 0; i &lt; str1.length; i++) {
	answer += str1[i] + str2[i];
}
return answer;
}
</code></pre></div></div>

<p><br /><br /><br />
문제 출처 -<a href="https://programmers.co.kr/"> 프로그래머스</a></p>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[문제1. 길이가 같은 문자열 배열 my_strings와 이차원 정수 배열 parts가 매개변수로 주어집니다. parts[i]는 [s, e] 형태로, my_string[i]의 인덱스 s부터 인덱스 e까지의 부분 문자열을 의미합니다. 각 my_strings의 원소의 parts에 해당하는 부분 문자열을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.]]></summary></entry><entry><title type="html">파이썬 기초</title><link href="http://localhost:4000/jekyll/update/2023/05/18/w-python.html" rel="alternate" type="text/html" title="파이썬 기초" /><published>2023-05-18T19:32:21+09:00</published><updated>2023-05-18T19:32:21+09:00</updated><id>http://localhost:4000/jekyll/update/2023/05/18/w-python</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/05/18/w-python.html"><![CDATA[<ul>
  <li>문자형 자료는 immutable 자료형이면서, 시퀸스 자료형 &gt; 슬라이싱으로 처리, 반복문 가능</li>
  <li>for문 범위 설정에서 마지막 숫자는 범위에 포함되지 않는다</li>
  <li>join() &gt; 리스트 문자열로 변환</li>
  <li>split &gt; 문자열 리스트로 변환(구분자 기준으로)</li>
  <li>부분 문자열(in/not in)</li>
  <li>list.sort()</li>
  <li>+= 연사자는 개별적인 원소를 만든다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>answer += strArr[i].upper()
answer = ['a', 'b', 'c', ... ]
instead
answer.append(strArr[i].upper())
</code></pre></div></div>
<ul>
  <li>if</li>
  <li>elif</li>
  <li>else</li>
  <li>replace는 원본 문자열을 바꾸는게 아니라 ‘새로운 문자열’을 반환한다. 그래서 다시 한번 더 결과를 할당해야 한다.</li>
  <li>replace는 체인 형태로 사용 가능(‘ABBAAB’ -&gt; ‘BAABBA’)</li>
  <li>리스트 원소 삭제 &gt; 인덱스 활용(del, pop) 문자열 활용(remove( ))</li>
  <li>문자 공백 제거
    <ul>
      <li>strip : 문자열 양쪽 공백 제거</li>
      <li>lstrip : 문자열의 왼쪽 처음 공백 제거</li>
      <li>rstrip : 문자열의 오른쪽 공백 제거</li>
      <li>이중,삼중 리스트 인덱싱</li>
    </ul>
  </li>
</ul>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[문자형 자료는 immutable 자료형이면서, 시퀸스 자료형 &gt; 슬라이싱으로 처리, 반복문 가능 for문 범위 설정에서 마지막 숫자는 범위에 포함되지 않는다 join() &gt; 리스트 문자열로 변환 split &gt; 문자열 리스트로 변환(구분자 기준으로) 부분 문자열(in/not in) list.sort() += 연사자는 개별적인 원소를 만든다.]]></summary></entry><entry><title type="html">정수를 나선형으로 배치하기 (마방진 모양 만들기)</title><link href="http://localhost:4000/jekyll/update/2023/05/16/w-python.html" rel="alternate" type="text/html" title="정수를 나선형으로 배치하기 (마방진 모양 만들기)" /><published>2023-05-16T21:19:11+09:00</published><updated>2023-05-16T21:19:11+09:00</updated><id>http://localhost:4000/jekyll/update/2023/05/16/w-python</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/05/16/w-python.html"><![CDATA[<p><strong>문제</strong>
양의 정수 <code class="language-plaintext highlighter-rouge">n</code>이 매개변수로 주어지고, <code class="language-plaintext highlighter-rouge">n</code> * <code class="language-plaintext highlighter-rouge">n</code> 배열에 1부터 n^2까지 정수를
인덱스 [0][0]부터 시계방향 나선형으로 배치한 이차원 배열을 return 하는 함수를 만들기</p>

<p><strong>제한사항</strong>   <br />
1 &lt;= n &lt;= 30</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def solution(n):
    arr = [[0] * n for _ in range(n)]

    # 배열에 넣을 숫자 초기화
    num = 1

    # 테두리를 순서대로 채워나가는 반복문
    for i in range(n // 2):
        for j in range(i, n-i-1):
            arr[i][j] = num
            num += 1
        for j in range(i, n-i-1):
            arr[j][n-i-1] = num
            num += 1
        for j in range(i, n-i-1):
            arr[n-i-1][n-j-1] = num
            num += 1
        for j in range(i, n-i-1):
            arr[n-j-1][i] = num
            num += 1
    if n % 2 != 0:
        arr[n//2][n//2] = n*n

    # 배열 반환
    return arr
</code></pre></div></div>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[문제 양의 정수 n이 매개변수로 주어지고, n * n 배열에 1부터 n^2까지 정수를 인덱스 [0][0]부터 시계방향 나선형으로 배치한 이차원 배열을 return 하는 함수를 만들기]]></summary></entry><entry><title type="html">파이썬 자료형, 추상화 인터페이스, 자바스크립트 웹 워커 (w/chatGPT)</title><link href="http://localhost:4000/jekyll/update/2023/05/10/w-chatgpt.html" rel="alternate" type="text/html" title="파이썬 자료형, 추상화 인터페이스, 자바스크립트 웹 워커 (w/chatGPT)" /><published>2023-05-10T12:24:27+09:00</published><updated>2023-05-10T12:24:27+09:00</updated><id>http://localhost:4000/jekyll/update/2023/05/10/w-chatgpt</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/05/10/w-chatgpt.html"><![CDATA[<p><strong>컴프리헨션</strong>은 리스트, 딕셔너리, 집합 등의 컬렉션을 생성하기 위한 파이썬의 문법.
comprehension은 포함이라는 뜻을 가지고 있다.
컴프리헨션을 사용하면 반복문과 조건문을 결합하여 간결한 코드로 만들 수 있다.  <br />
<br /></p>

<ol>
  <li>파이썬 리스트 컴프리헨션과 제너레이터 표현식</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># **리스트 컴프리헨션**
[expression for item in iterable if condition]

# **예시 &gt; '()' 중괄호 제외하고 문자열로 join**
result = ''.join([c for c in some_iter if c not in '()'])

# **예시 &gt; 제너레이터 표현식으로**  
resultfinal = ''.join(c for c in resultd if c not in '()')
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># **리스트 컴프리헨션 예시2**
lst = [x**2 for x in range(10)]
print(lst)
# **리스트 생성 제너레이터 표현식 예시2**
gen = (x**2 for x in range(10))
for val in gen:
	print(val)
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># **딕셔너리 컴프리헨션 예시**
diction = {key:value for key, value in some_iter if some_condition}
# **딕셔너리 생성 제너레이터 표현식 예시**
1. diction = ((key,value) for key,value in some_iter if some_condition)
2. 위에서 dict() 함수 사용
</code></pre></div></div>

<ul>
  <li>제너레이터 객체도 값을 순차적으로 생성하는 이터러블한 객체</li>
  <li>
    <p>제너레이터 표현식은 리스트 컴프리헨션과 다르게 순차적으로 값을 생성하기 때문에 데이터가 클 때 사용하면 보다 
메모리를 효율적으로 사용할 수 있다.</p>
  </li>
  <li>추상화 인터페이스?
추상 인터페이스(abstract interface)는 구현 세부사항을 숨기고 인터페이스만 노출시키는 객체지향 프로그래밍에서의 개념. 즉, 인터페이스는 객체나 클래스가 제공하는 기능을 정의하는데, 추상 인터페이스는 인터페이스의 일부 메서드를 구현하지 않은 추상 클래스이며, 자식 클래스에서 추상 메서드를 구현하여 상속받는 클래스가 반드시 구현해야 하는 메서드를 정의.</li>
</ul>

<p>파이썬에서 이터레이터(iterator)는 추상 인터페이스의 일종으로, 반복 가능한 객체(iterable)에서 값을 차례로 생성해내는 추상 메서드 <strong>next</strong>()를 구현하는 객체.
이터레이터를 사용하여 반복 가능한 객체에 접근하는 코드는 반복 가능한 객체의 구현과 무관하게 작동하므로, 추상 인터페이스의 개념에 부합.</p>

<p><br />
<code class="language-plaintext highlighter-rouge">chatGPT에게 질문</code></p>

<blockquote>
  <p>추상화 인터페이스에 대해서 예시로 설명해줘</p>
</blockquote>

<p>예를 들어서 “차”라는 개념이 있다고 해보겠습니다. 우리는 “차”를 볼 때, 차가 가지고 있는 속성들을 고려합니다. 예를 들어 “색상”, “차종”, “최대속도”, “연비” 등등이 있을 수 있습니다. 하지만 우리가 “차”라고 하면서도 정확히 어떤 차종, 어떤 색상, 어떤 최대속도, 어떤 연비의 차인지는 모릅니다. 이렇게 “차”라는 개념 자체는 구체적인 특징이 없는 추상적인 개념이 됩니다.</p>

<p>그렇다면 “차”라는 추상적인 개념이 어떻게 코드로 표현될 수 있을까요? 추상화 인터페이스는 이러한 추상적인 개념을 코드로 표현한 것입니다. 예를 들어 “차”라는 개념을 표현하기 위해서, “차”가 가지고 있는 공통적인 속성들을 추상화한 클래스를 만들 수 있습니다. 이 클래스에는 “색상”, “차종”, “최대속도”, “연비” 등과 같은 속성들이 선언되어 있지만, 그 값은 정해져 있지 않습니다. 이렇게 추상화 인터페이스는 구체적인 구현을 담당하는 클래스와 구분되어 있으며, 이를 상속받은 구현 클래스에서 구체적인 값을 할당해 줄 수 있습니다.</p>

<p>파이썬에서 추상화 인터페이스로 만든 것들은 보통 특정한 작업을 수행하기 위한 규약을 정의하는 것입니다. 예를 들어 collections.abc 모듈에서는 시퀀스, 매핑, 세트 등의 컬렉션 타입들을 추상화한 인터페이스를 제공합니다. 이러한 추상화 인터페이스를 상속받는 클래스는 해당 컬렉션 타입의 규약을 준수하도록 강제되며, 따라서 일관된 인터페이스를 제공함으로써 다형성을 지원합니다. 또한, 파이썬에서는 이러한 추상화 인터페이스를 이용하여 다양한 라이브러리와 프레임워크가 작동하도록 만들어집니다. 예를 들어, pandas 라이브러리에서는 데이터프레임이라는 복잡한 자료구조를 추상화한 인터페이스를 제공하여, 다양한 데이터프레임 형식을 일관되게 다룰 수 있도록 합니다.</p>

<p>파이썬에서 제공하는 추상화 인터페이스는 여러 가지가 있지만, 가장 기본적인 것들은 다음과 같습니다.</p>

<ul>
  <li>이터레이터 (Iterator)</li>
  <li>제너레이터 (Generator)</li>
  <li>시퀀스 (Sequence)</li>
  <li>매핑 (Mapping)</li>
  <li>컨테이너 (Container)</li>
  <li>호출 가능한 객체 (Callable)
이 외에도, 파일 객체 (File Object), 컨텍스트 관리자 (Context Manager), 비동기 제너레이터 (Asynchronous Generator) 등 다양한 추상화 인터페이스가 있습니다.</li>
</ul>

<blockquote>
  <p>Shell 과 Kernel 에 대해서 알려줘</p>
</blockquote>

<p>쉘(shell)은 컴퓨터 운영 체제에서 사용자와 커널(kernel) 사이를 중개하는 인터페이스입니다. 쉘은 사용자가 명령을 입력하면 이를 해석하여 커널에 전달하고, 그 결과를 다시 사용자에게 보여주는 역할을 합니다.</p>

<p>예를 들어, 유닉스(UNIX) 계열의 운영 체제에서는 사용자가 터미널(terminal)에 명령을 입력하면, 이를 해석하여 커널에 전달하는 쉘인 bash나 zsh 등이 있습니다.</p>

<p>커널은 운영 체제의 핵심 부분으로, 하드웨어와 소프트웨어 사이에서 중재자 역할을 합니다. 운영 체제에서 실행되는 모든 프로세스와 시스템 자원은 커널을 통해 관리됩니다.</p>

<p>즉, 쉘과 커널은 운영 체제에서 사용자와 하드웨어 간의 중개자 역할을 수행하는 핵심 요소입니다.</p>

<p>커널은 운영체제의 핵심적인 부분으로, 프로그램이 하드웨어와 상호작용할 수 있도록 인터페이스를 제공합니다. 즉, 운영체제의 기능 중 하나인 하드웨어 추상화를 담당하며, 하드웨어를 직접 다루는 일은 대부분 커널에서 처리됩니다.</p>

<p>커널은 운영체제와 밀접하게 연관되어 있으며, 운영체제는 주로 커널과 여러 가지 시스템 도구 및 유틸리티로 구성됩니다. 운영체제는 커널을 기반으로 하고, 커널은 운영체제에서 가장 중요한 부분입니다.</p>

<p>커널은 운영체제의 핵심적인 부분이기 때문에, 운영체제의 안정성과 성능에 매우 중요한 역할을 합니다. 따라서 커널의 설계와 구현은 매우 신중하게 이루어져야 하며, 대부분의 운영체제에서 커널은 고도로 최적화되고 최신 기술을 적용하여 개발됩니다.</p>

<blockquote>
  <p>하드웨어 추상화?</p>
</blockquote>

<p>하드웨어 추상화란, 하드웨어의 구체적인 동작 방식을 추상화하여 프로그래머나 사용자가 하드웨어와 상호작용할 때 일정 수준의 추상화된 인터페이스를 제공하는 것을 말합니다. 이는 하드웨어를 쉽게 다룰 수 있도록 도와주며, 프로그래밍 언어와 운영체제 등에서 사용됩니다.</p>

<p>하드웨어 추상화는 컴퓨터의 복잡한 하드웨어 시스템을 단순화하고, 추상화된 인터페이스를 통해 사용자가 하드웨어를 조작하기 쉽게 만듭니다. 예를 들어, 컴퓨터의 CPU는 매우 복잡한 기능을 가지고 있지만, 운영체제는 이를 추상화하여 프로그래머가 쉽게 사용할 수 있도록 도와줍니다.</p>

<p>하드웨어 추상화의 장점으로는 다양한 하드웨어에서 동일한 소프트웨어를 실행할 수 있으며, 하드웨어의 변경으로 인한 소프트웨어 수정이 최소화됩니다. 또한, 하드웨어 추상화를 통해 시스템 보안을 강화할 수 있습니다.</p>

<blockquote>
  <p>리눅스와 유닉스, 맥 os 에 대해서 알려줘!</p>
</blockquote>

<p>유닉스(Unix)는 초기에는 벨 연구소(Bell Labs)에서 개발되었고, 이후 다양한 배포판이 등장하면서 많은 곳에서 사용되고 있습니다.</p>

<p>리눅스(Linux)는 리누스 토발즈(Linus Torvalds)가 만든 운영체제 커널로, 유닉스와 매우 유사한 인터페이스를 가지고 있습니다. 리눅스는 오픈소스 운동과 더불어 발전하였고, 현재는 다양한 배포판이 존재합니다.</p>

<p>맥 OS(Mac OS)는 애플이 개발한 운영체제로, 유닉스 기반으로 만들어졌습니다. 초기에는 맥 OS 9와 같이 다른 운영체제와 큰 차이가 있었지만, 2001년부터 맥 OS X가 출시되면서 유닉스 기반으로 완전히 재구성되었습니다. 따라서 맥 OS는 유닉스와 매우 유사한 인터페이스를 가지고 있습니다.</p>

<p>이렇게 유닉스와 리눅스, 맥 OS는 모두 유닉스와 비슷한 인터페이스를 가지고 있으며, 하드웨어 추상화를 통해 다양한 하드웨어 환경에서 동작할 수 있습니다.</p>

<blockquote>
  <p>둘 중 뭐가 먼저 나왔어?</p>
</blockquote>

<p>UNIX가 먼저 개발되었습니다. 1960년대 후반부터 1970년대 초반까지 벨 연구소에서 개발되었으며, 초기에는 대학과 연구소에서 주로 사용되다가 시간이 흐르면서 비즈니스 및 정부 분야에서도 사용되게 되었습니다. 반면, Linux는 리누스 토발즈가 1991년에 처음 개발했으며, UNIX의 기능을 확장하고 개선한 것이라고 볼 수 있습니다.</p>

<blockquote>
  <p>자바스크립트 멀티스레딩 기법에 대해서 알려줘</p>
</blockquote>

<p>자바스크립트는 단일 스레드 언어로, 한 번에 한 가지 일만 처리할 수 있습니다. 이는 자바스크립트가 브라우저의 UI 스레드와 같은 매우 중요한 작업을 처리해야 하는 경우에도 적용됩니다.</p>

<p>하지만 여전히 자바스크립트에서 동시성을 활용하기 위해 멀티 스레딩 기법을 사용할 수 있습니다. 이를 위해 일부 브라우저는 Web Worker라는 기능을 제공합니다.</p>

<p>Web Worker는 자바스크립트 코드를 백그라운드 스레드에서 실행하도록 허용합니다. 이것은 메인 스레드에서 실행하는 것과 독립적으로 실행되며, 메인 스레드가 블로킹되지 않고도 다른 일을 계속할 수 있도록 합니다. 또한 Web Worker는 메인 스레드와는 다른 샌드박스 환경에서 실행되기 때문에 보안상 안전합니다.</p>

<p>Web Worker를 사용하면 다음과 같은 일을 할 수 있습니다.</p>

<p>복잡한 작업을 백그라운드 스레드에서 실행하고, 메인 스레드에서 다른 작업을 수행할 수 있습니다.
다중 작업을 수행할 수 있습니다. 예를 들어, 웹 페이지에서 파일을 업로드하는 경우에는 백그라운드 스레드에서 파일을 업로드하고, 메인 스레드에서는 다른 작업을 수행할 수 있습니다.
병렬 처리를 할 수 있습니다. 예를 들어, 대용량 데이터를 처리할 때 백그라운드 스레드에서 데이터를 분할하고, 각각의 작업을 병렬로 처리할 수 있습니다.
그러나 Web Worker는 데이터를 공유하기가 어렵기 때문에 멀티 스레딩을 활용하기가 다소 까다롭습니다. 또한 Web Worker는 오래된 브라우저에서 지원되지 않을 수도 있습니다.</p>

<blockquote>
  <p>스레드란?</p>
</blockquote>

<p>스레드(Thread)란 프로세스(Process) 내에서 실행되는 실행 단위를 의미합니다. 각 프로세스는 최소한 하나 이상의 스레드를 가지며, 스레드는 해당 프로세스의 자원을 공유하면서 실행됩니다. 이때, 각 스레드는 독립적인 실행 흐름을 가지며, 하나의 프로세스 내에서 여러 개의 스레드가 동시에 작업할 수 있습니다. 스레드는 프로세스 내에서 코드를 실행하고, CPU 자원과 메모리 등의 자원을 공유하면서 동작합니다. 따라서 스레드를 사용하면 멀티태스킹과 병렬처리를 구현할 수 있습니다.</p>

<p>자바스크립트 언어 자체에서는 멀티 스레딩을 지원하지 않기 때문에, 일반적으로 싱글 스레드 언어로 분류됩니다. 그러나 최근에는 웹 워커(Web Worker) API를 통해 멀티 스레딩을 구현할 수 있게 되었습니다. 이 API는 별도의 스레드에서 자바스크립트 코드를 실행하므로, 웹 애플리케이션에서 백그라운드 작업이나 병렬 처리를 수행할 수 있습니다.</p>

<blockquote>
  <p>자바스크립트 비동기 처리 방식과 비슷한건가?</p>
</blockquote>

<p>네, 자바스크립트의 비동기 처리 방식과 멀티 스레딩의 동작 방식은 유사합니다. 자바스크립트에서 비동기 처리를 하기 위해 사용되는 콜백 함수나 프로미스, 비동기 함수 등은 멀티 스레딩의 쓰레드와 같은 역할을 하게 됩니다. 즉, 비동기적으로 실행되는 코드들이 병렬적으로 실행될 수 있도록 도와주는 기술적인 방식이라고 볼 수 있습니다. 다만, 자바스크립트에서의 비동기 처리는 멀티 스레딩과는 다른 특징을 가지고 있기 때문에 완전히 동일한 개념은 아닙니다.</p>

<blockquote>
  <p>자바스크립트에도 인터페이스 추상화 같은 개념이 있어?</p>
</blockquote>

<p>파이썬의 추상화 인터페이스와 같은 개념은 자바스크립트에서도 존재합니다. 자바스크립트에서 인터페이스와 관련된 개념으로는 TypeScript에서 제공하는 Interface, JavaScript에서는 ECMAScript 6부터 추가된 Class 문법에서 제공하는 interface 등이 있습니다. 이들은 객체나 클래스의 속성, 메서드 등을 정의하는 추상화된 인터페이스를 제공하며, 이를 구현한 클래스나 객체는 인터페이스에서 정의한 대로 동작해야 합니다. 이를 통해 코드의 가독성, 유지보수성, 확장성을 높일 수 있습니다.</p>

<p>파이썬에서는 추상화 인터페이스를 지원하는데, 이를 통해 여러 구현체들이 동일한 인터페이스를 구현함으로써 코드의 재사용성과 유연성을 높일 수 있습니다. 예를 들어, collections.abc 모듈에는 다양한 추상화 인터페이스가 정의되어 있습니다. 예를 들어, Sequence, Mapping, Iterable, Callable 등은 모두 추상화 인터페이스입니다.</p>

<p>자바스크립트에도 인터페이스를 지원하는 기능은 있지만, 파이썬에서의 추상화 인터페이스와는 다릅니다. 자바스크립트에서는 인터페이스를 정의할 때 일반적으로 class 문법을 사용합니다. 클래스 내부에서 구현되는 메서드들을 인터페이스라고 볼 수 있습니다. 이러한 인터페이스를 사용하면, 다양한 클래스들이 동일한 인터페이스를 구현함으로써 코드의 재사용성과 유연성을 높일 수 있습니다.</p>

<p>하지만 자바스크립트에서는 인터페이스를 명시적으로 선언하지 않고, 클래스의 메서드를 직접 호출하거나 객체의 프로퍼티에 접근하는 것이 일반적입니다. 따라서 자바스크립트에서는 파이썬처럼 명시적으로 추상화 인터페이스를 정의하는 것은 일반적이지 않습니다.</p>

<p><code class="language-plaintext highlighter-rouge">프로그래밍 초심자 입장에서는 공부하는데 도움이 될 것 같다.</code><br />
<code class="language-plaintext highlighter-rouge">하지만 정확한 정보인지는 계속해서 체크해야 할 듯..</code></p>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[컴프리헨션은 리스트, 딕셔너리, 집합 등의 컬렉션을 생성하기 위한 파이썬의 문법. comprehension은 포함이라는 뜻을 가지고 있다. 컴프리헨션을 사용하면 반복문과 조건문을 결합하여 간결한 코드로 만들 수 있다.]]></summary></entry><entry><title type="html">Github page 관련 메모</title><link href="http://localhost:4000/jekyll/update/2023/04/29/post.html" rel="alternate" type="text/html" title="Github page 관련 메모" /><published>2023-04-29T13:41:34+09:00</published><updated>2023-04-29T13:41:34+09:00</updated><id>http://localhost:4000/jekyll/update/2023/04/29/post</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/04/29/post.html"><![CDATA[<ol>
  <li>rbenv 이용하여 Ruby 설치
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ brew install rbenv
</code></pre></div>    </div>
  </li>
  <li>Ruby 버전 설치
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rbenv install 0.0.0 # 원하는 Ruby 버전 설치
$ rbenv rehash        # Ruby 설치 후 재실행 
</code></pre></div>    </div>
  </li>
  <li>
    <p>환경 설정 명령어 추가(내용 확인 필요)</p>
  </li>
  <li>Ruby 버전 변경
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rbenv global 0.0.0
$ rbenv local 0.0.0
</code></pre></div>    </div>
  </li>
  <li>적용된 Ruby 버전 확인
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rbenv versions
</code></pre></div>    </div>
  </li>
  <li>Ruby 버전 삭제/설치
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rbenv uninstall 0.0.0
$ rbenv install 0.0.0
</code></pre></div>    </div>
  </li>
  <li>rbenv 설치 확인
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbenv versions
</code></pre></div>    </div>
  </li>
  <li>설치 가능한 Ruby 버전 확인
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rbenv install -l
</code></pre></div>    </div>
  </li>
  <li>그 외 확인해 볼 것
rbenv PATH / 쉘 설정 파일 / git 관련 내용 복습 필요</li>
</ol>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[rbenv 이용하여 Ruby 설치 $ brew install rbenv Ruby 버전 설치 $ rbenv install 0.0.0 # 원하는 Ruby 버전 설치 $ rbenv rehash # Ruby 설치 후 재실행 환경 설정 명령어 추가(내용 확인 필요)]]></summary></entry><entry><title type="html">Github page 블로그 커스터마이징 (w/Jekyll theme)</title><link href="http://localhost:4000/jekyll/update/2023/04/05/post.html" rel="alternate" type="text/html" title="Github page 블로그 커스터마이징 (w/Jekyll theme)" /><published>2023-04-05T14:11:30+09:00</published><updated>2023-04-05T14:11:30+09:00</updated><id>http://localhost:4000/jekyll/update/2023/04/05/post</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/04/05/post.html"><![CDATA[<p>Github page를 만들고 조금씩 고쳐나가고 있다. 처음 눈에 들어온건 minima 테마에서 상단에 보이는 디폴트 회색라인을 삭제하고 싶었다. jekyll 구조가 처음이어서 좀 헤매다가 방법을 찾았다. 
<br /><br />
Jekyll은 정적 웹사이트 생성기이다(루비로 만든 프레임워크) Github을 활용하여 사이트를 운영할 수 있다.
Jekyll 공식 사이트에 설명이 잘 나와 있어서 천천히 읽어보면 좋을 것 같다.</p>

<ul>
  <li>CSS를 변경하고 싶다면, Jekyll theme 구조를 파악해야 한다. 구조 파악 후 수정이 필요한 파일을 찾아야 한다.</li>
  <li>수정해야 할 파일을 찾았으면 로컬 파일로 덮어쓰기 하면 된다.(처음엔 이게 무슨 말인가 했네) &gt; <a href="https://jekyllrb-ko.github.io/docs/themes/"> jekyll 구조 파악하기 </a></li>
  <li>Jekyll 과 Ruby, bundler, gem 조금 더 알아볼 필요가 있을 것 같다.</li>
</ul>

<p>** NEXT TO DO</p>
<ol>
  <li>메뉴 카테고리 추가하기</li>
  <li>Github admin 페이지 metadata field 익히기</li>
  <li>Github admin 필요한 것들 추가해보고 싶다. admin 페이지 post 기능 잘 활용하기</li>
  <li>Github 사용방법 조금씩 연습하자</li>
  <li>SCSS 과 SASS 내용도 한번 찾아보자(로컬 서버 deprecated 오류 관련)</li>
</ol>]]></content><author><name>Hong Seok Pyo</name><email>seokpyo1110@gmail.com</email></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Github page를 만들고 조금씩 고쳐나가고 있다. 처음 눈에 들어온건 minima 테마에서 상단에 보이는 디폴트 회색라인을 삭제하고 싶었다. jekyll 구조가 처음이어서 좀 헤매다가 방법을 찾았다. Jekyll은 정적 웹사이트 생성기이다(루비로 만든 프레임워크) Github을 활용하여 사이트를 운영할 수 있다. Jekyll 공식 사이트에 설명이 잘 나와 있어서 천천히 읽어보면 좋을 것 같다.]]></summary></entry></feed>